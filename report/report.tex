% !TeX document-id = {228518e8-78bc-4d31-8f71-78944704b115}
% !TeX TXS-program:compile = txs:///pdflatex/[--shell-escape]
\documentclass[12pt]{article}

% For colors
\usepackage[dvipsnames]{xcolor}
\definecolor{codebg}{rgb}{0.94,0.94,0.94}
\definecolor{outbg}{rgb}{0.90,0.90,0.95}

% General packages
\usepackage{physics, amsmath, amssymb}
\usepackage{booktabs}
\usepackage[section]{placeins}
\usepackage{cleveref}
\usepackage{graphicx}
\usepackage{siunitx}
\usepackage{multicol}
\usepackage{minted}
\usepackage[super]{nth}

% Better looking captions
\usepackage{caption}
\captionsetup{margin=0.5in, labelfont=bf}

\newcommand{\eg}{\textit{e}.\textit{g.}}

% Packages with options
\usepackage[margin=1in]{geometry}
\usepackage[kerning=true, tracking=true]{microtype}
\usepackage{tikz}

% Redefine section-title macros
% \titleformat{command}[shape]{format}{label}{sep}{hefore-code}[after-code]
\usepackage{titlesec}
\renewcommand{\thesection}{\Roman{section}}
\titleformat{\section}[hang]{\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}[hang]{\large\scshape\filcenter}{\thesubsection}{1em}{}

\usepackage{csquotes}

% Definitions and settings
\renewcommand{\vec}[1]{\boldsymbol{\mathbf{#1}}}
\newcommand{\ihat}{\hat{\textbf{\i}}}
\newcommand{\jhat}{\hat{\textbf{\j}}}
\newcommand{\khat}{\hat{\textbf{k}}}
\newcommand{\bigO}[1]{\mathcal{O}\qty(#1)}
\graphicspath{Images/}

\begin{document}
\title{Programming Relativistic Physics in Virtual Reality}
\author{Thomas Longo \and Vince Mutolo}
\maketitle

\section*{Introduction}
The ultimate goal of this project is to create a physics engine that works in special relativistic frames. After creating this engine, we will project a simple scene into Villanova's CAVE Automatic Virtual Environment (CAVE). In doing this, we intend to learn about special relativity and how the observer's view changes based on its speed and its speed relative to other objects. In addition, we intend to convey this knowledge to other students in a fun and creative way through the use of the CAVE.

\section*{Theory}
There was a very small amount of theory for our project because our project was mostly computer programming. Therefore, this theory will mostly be used to define some of the terms that will be used in the following sections for how our code works.

With our initial goal of programming a relativistic physics game engine, we first, needed to get acquainted with the system that we were using. We decided to use Unity, which is a game development engine that is compatible with the CAVE and has a number of physical systems already preprogrammed into it. However, in working with Unity we must understand how Unity defines its space. It uses a left handed coordinate axis system where $y$ is defined to be up. Second, Unity uses a system where all scripts are written in C\#. This is a coding language that was unfamiliar to us, but was close to c++. 

In programming in C\#, one of the first things that we learned was the difference between the three types of update loops associated with Unity, the \textit{Update}, \textit{FixedUpdate}, and \textit{LateUpdate} loops. These loops trigger at different times. The \textit{Update} loop, updates everything within it once per scene frame, and therefore, is very useful for keeping track of counters or inputs. The \textit{FixedUpdate} loop can update anything within it based on any time interval, and therefore, is typically the main update loop for updating objects that have physical properties associated with them. Lastly, the \textit{LateUpdate} loop updates anything within it after the \textit{Update} loop, and therefore, it is mostly useful for the camera which is typically following the object that is being updated.

\section*{Methods}
\subsection*{Introduction to Unity}
\begin{itemize}
	\item We began by getting acquainted with Unity through the use of various tutorials.
	\item In these tutorials, we learned about how to use the GUI interface associated with Unity.
	\item Then, we learned about how to use C\# and how to apply different scripts to object in the game.
\end{itemize}

\subsection*{Simple Physics}
\begin{itemize}
	\item We programmed a simple scene that takes into account Newton's Law of Gravitation and Hooke's Law.
	\item After, we made a basic physics engine to update an object's position, based on an inputed velocity and acceleration.
\end{itemize}

\subsection*{Relativistic Tests}
\begin{itemize}
	\item After becoming acquainted with Unity and C\#, we made a simple 1-D length contraction scene in Unity. 
	\item In this scene, when the user presses ``spacebar'' the object increases its speed by $0.1c$ and all objects in the scene contract accordingly.
\end{itemize}

\section*{Results}
We applied what we learned in these simple laws to a basic physics engine that changes an objects position based on an inputed velocity and acceleration. To get the object to accelerate, we applied one of the things built into Unity, the \textit{rigidbody} component. This is a function within unity that allows one to give any shape a rigid body which allows other objects to interact with it via elastic and inelastic collisions. In addition, we can give an object mass and change an objects translational and angular drag. For our final scene we kept this script as our main physics engine and used it as a class to act on our observer. 

Next, we programmed a simple length contraction of a sphere based on the speed of an observer. To do this, we needed to use the length contraction formula, which states:
\begin{equation}
L = L_0\gamma^{-1}
\end{equation}
Where $L_0$ is the proper length, or the length of an object in its rest frame. $L$ is the length observed by an observer in relative motion with respect to that object, and $\gamma$ is:
\begin{equation}
\gamma = (1-\beta^2)^{-1/2}
\end{equation}
For this scene, we made the camera the observer, so that the viewer is always in the position of the moving object and will get to see the other objects contract. Therefore, using our main physics engine we attached a velocity to our camera, and we attached a generic object variable to the camera as well. Then, in unity, we mapped our object, the sphere, to the camera, so that as the camera's speed changed so to did the objects length.
\inputminted[firstline=2,lastline=10,linenos,fontsize=\footnotesize]{csharp}{../unity/Assets/Scripts/CameraFollow.cs}





 
\end{document}